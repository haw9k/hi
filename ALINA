import random
import math


def fast_pow_mod(a, exponent, n, operation_name=""):
    """–ë—ã—Å—Ç—Ä–æ–µ –≤–æ–∑–≤–µ–¥–µ–Ω–∏–µ –≤ —Å—Ç–µ–ø–µ–Ω—å –ø–æ –º–æ–¥—É–ª—é —Å –≤—ã–≤–æ–¥–æ–º —à–∞–≥–æ–≤"""
    i = exponent
    p = 1
    a_k = a % n
    step = 1

    print(f"\n{operation_name} —á–∏—Å–ª–∞ {a}:")
    print(f"{'k':>2} | {'a_k':>10} | {'i':>10} | {'s':>3} | {'p':>10}")
    print("-" * 45)

    while i > 0:
        s = i % 2
        if s == 1:
            p = (p * a_k) % n
        print(f"{step:>2} | {a_k:>10} | {i:>10} | {s:>3} | {p:>10}")
        a_k = (a_k * a_k) % n
        i = i // 2
        step += 1

    print(f"–ò—Ç–æ–≥–æ–≤—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç: {p} ({a}^{exponent} mod {n})\n")
    return p


class PrimeGenerator:
    def __init__(self):
        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –º–∞–ª—ã–µ –ø—Ä–æ—Å—Ç—ã–µ —á–∏—Å–ª–∞ –¥–æ 200 –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏
        self.small_primes = self._generate_small_primes(200)

    def _generate_small_primes(self, limit):
        """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Å–ø–∏—Å–æ–∫ –ø—Ä–æ—Å—Ç—ã—Ö —á–∏—Å–µ–ª –¥–æ –∑–∞–¥–∞–Ω–Ω–æ–≥–æ –ø—Ä–µ–¥–µ–ª–∞"""
        sieve = [True] * (limit + 1)
        sieve[0] = sieve[1] = False

        for i in range(2, int(math.sqrt(limit)) + 1):
            if sieve[i]:
                for j in range(i * i, limit + 1, i):
                    sieve[j] = False

        return [i for i, is_prime in enumerate(sieve) if is_prime]

    def rabin_miller_test(self, p, k=5, show_steps=False):

        """
        –¢–µ—Å—Ç –†–∞–±–∏–Ω–∞‚Äì–ú–∏–ª–ª–µ—Ä–∞ –Ω–∞ –ø—Ä–æ—Å—Ç–æ—Ç—É —Å —Ä–∞—Å—á–µ—Ç–æ–º –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏
        """
        if p == 2 or p == 3:
            return True
        if p <= 1 or p % 2 == 0:
            return False

        # –†–∞–∑–ª–æ–∂–µ–Ω–∏–µ p-1 = 2^b * m
        b = 0
        m = p - 1
        while m % 2 == 0:
            m //= 2
            b += 1

        print(f"\n--- –ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–∞ –†–∞–±–∏–Ω–∞‚Äì–ú–∏–ª–ª–µ—Ä–∞ –¥–ª—è —á–∏—Å–ª–∞ {p} ---")
        print(f"–†–∞–∑–ª–æ–∂–µ–Ω–∏–µ: {p-1} = 2^{b} * {m}")


        passed_tests = 0
        probability_history = []

        for test_num in range(1, k + 1):
            a = random.randint(2, p - 2)
            print(f"\n=== –¢–µ—Å—Ç #{test_num}: —Å–≤–∏–¥–µ—Ç–µ–ª—å a = {a} ===")

            if show_steps:
                z = fast_pow_mod(a, m, p, f"–í—ã—á–∏—Å–ª–µ–Ω–∏–µ a^m mod p")
            else:
                z = pow(a, m, p)

            # –®–∞–≥ (3): –µ—Å–ª–∏ z = 1 –∏–ª–∏ z = p-1, —Ç–µ—Å—Ç –ø—Ä–æ–π–¥–µ–Ω
            if z == 1 or z == p - 1:
                passed_tests += 1
                error_prob = (1/4) ** passed_tests
                confidence = (1 - error_prob)
                probability_history.append(confidence)

                print(f" –¢–µ—Å—Ç #{test_num} –ø—Ä–æ–π–¥–µ–Ω (z = {z})")
                print(f" –ü—Ä–æ–π–¥–µ–Ω–æ —Ç–µ—Å—Ç–æ–≤: {passed_tests}/{test_num}")
                print(f" –¢–µ–∫—É—â–∞—è –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –ø—Ä–æ—Å—Ç–æ—Ç—ã: {confidence:.6f}%")

                continue

            j = 0
            test_passed = False

            # –®–∞–≥ (5): –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ–µ –≤–æ–∑–≤–µ–¥–µ–Ω–∏–µ –≤ –∫–≤–∞–¥—Ä–∞—Ç
            while j < b - 1:
                j += 1

                if show_steps:
                    z = fast_pow_mod(z, 2, p, f"–í–æ–∑–≤–µ–¥–µ–Ω–∏–µ –≤ –∫–≤–∞–¥—Ä–∞—Ç (—à–∞–≥ {j})")
                else:
                    z = pow(z, 2, p)

                # –®–∞–≥ (4): –µ—Å–ª–∏ j > 0 –∏ z = 1 - —á–∏—Å–ª–æ —Å–æ—Å—Ç–∞–≤–Ω–æ–µ
                if j > 0 and z == 1:
                    print(f" –¢–µ—Å—Ç #{test_num} –ø—Ä–æ–≤–∞–ª–µ–Ω (j={j}, z=1)")
                    print(f" –ü—Ä–æ–π–¥–µ–Ω–æ —Ç–µ—Å—Ç–æ–≤ –¥–æ –ø—Ä–æ–≤–∞–ª–∞: {passed_tests}/{test_num}")
                    if passed_tests > 0:
                        final_error_prob = (1/4) ** passed_tests
                        print(f" –ò—Ç–æ–≥–æ–≤–∞—è –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –ø—Ä–æ—Å—Ç–æ—Ç—ã: {(1 - final_error_prob) :.6f}%")
                    return False

                # –®–∞–≥ (5): –µ—Å–ª–∏ z = p-1 - —Ç–µ—Å—Ç –ø—Ä–æ–π–¥–µ–Ω
                if z == p - 1:
                    passed_tests += 1
                    error_prob = (1/4) ** passed_tests
                    confidence = (1 - error_prob)
                    probability_history.append(confidence)

                    print(f" –¢–µ—Å—Ç #{test_num} –ø—Ä–æ–π–¥–µ–Ω (j={j}, z={p-1})")
                    print(f" –ü—Ä–æ–π–¥–µ–Ω–æ —Ç–µ—Å—Ç–æ–≤: {passed_tests}/{test_num}")
                    print(f" –¢–µ–∫—É—â–∞—è –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –ø—Ä–æ—Å—Ç–æ—Ç—ã: {confidence:.6f}%")
                    test_passed = True
                    break

            # –®–∞–≥ (6): –µ—Å–ª–∏ j = b –∏ z ‚â† p-1 - —á–∏—Å–ª–æ —Å–æ—Å—Ç–∞–≤–Ω–æ–µ
            if not test_passed and z != p - 1:
                print(f" –¢–µ—Å—Ç #{test_num} –ø—Ä–æ–≤–∞–ª–µ–Ω (j={b}, z={z} != {p-1})")
                print(f" –ü—Ä–æ–π–¥–µ–Ω–æ —Ç–µ—Å—Ç–æ–≤ –¥–æ –ø—Ä–æ–≤–∞–ª–∞: {passed_tests}/{test_num}")
                if passed_tests > 0:
                    final_error_prob = (1/4) ** passed_tests
                    print(f" –ò—Ç–æ–≥–æ–≤–∞—è –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –ø—Ä–æ—Å—Ç–æ—Ç—ã: {(1 - final_error_prob) :.6f}%")
                return False

        # –í—Å–µ —Ç–µ—Å—Ç—ã –ø—Ä–æ–π–¥–µ–Ω—ã —É—Å–ø–µ—à–Ω–æ
        final_error_prob = (1/4) ** passed_tests
        final_confidence = (1 - final_error_prob)

        print(f"\n –í–°–ï –¢–ï–°–¢–´ –ü–†–û–ô–î–ï–ù–´ –£–°–ü–ï–®–ù–û!")
        print(f" –ò—Ç–æ–≥–æ–≤—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã:")
        print(f"–ü—Ä–æ–π–¥–µ–Ω–æ —Ç–µ—Å—Ç–æ–≤: {passed_tests}/{k}")
        print(f"–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –ø—Ä–æ—Å—Ç–æ—Ç—ã: {final_confidence:.8f}%")


        return True

    def is_divisible_by_small_primes(self, n):
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –¥–µ–ª–∏–º–æ—Å—Ç—å –Ω–∞ –º–∞–ª—ã–µ –ø—Ä–æ—Å—Ç—ã–µ —á–∏—Å–ª–∞"""
        for prime in self.small_primes:
            if prime >= n:
                break
            if n % prime == 0:
                return True
        return False

    def generate_prime(self, bits):
        """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –ø—Ä–æ—Å—Ç–æ–µ —á–∏—Å–ª–æ –∑–∞–¥–∞–Ω–Ω–æ–π –±–∏—Ç–æ–≤–æ–π –¥–ª–∏–Ω—ã"""
        while True:
            # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ —á–∏—Å–ª–∞ –∑–∞–¥–∞–Ω–Ω–æ–π –¥–ª–∏–Ω—ã
            p = random.getrandbits(bits)

            # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—Ç–∞—Ä—à–∏–π –∏ –º–ª–∞–¥—à–∏–π –±–∏—Ç—ã
            p |= (1 << (bits - 1))  # —Å—Ç–∞—Ä—à–∏–π –±–∏—Ç = 1
            p |= 1  # –º–ª–∞–¥—à–∏–π –±–∏—Ç = 1 (–Ω–µ—á—ë—Ç–Ω–æ—Å—Ç—å)

            if p.bit_length() != bits:
                continue

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥–µ–ª–∏–º–æ—Å—Ç—å –º–∞–ª—ã–º–∏ –ø—Ä–æ—Å—Ç—ã–º–∏
            if self.is_divisible_by_small_primes(p):
                continue

            # –¢–µ—Å—Ç –†–∞–±–∏–Ω–∞‚Äì–ú–∏–ª–ª–µ—Ä–∞
            if self.rabin_miller_test(p, k=5):
                print(f"\n –ù–∞–π–¥–µ–Ω–æ –≤–µ—Ä–æ—è—Ç–Ω–æ –ø—Ä–æ—Å—Ç–æ–µ —á–∏—Å–ª–æ: {p}")
                print(f"–ë–∏—Ç–æ–≤–∞—è –¥–ª–∏–Ω–∞: {p.bit_length()} –±–∏—Ç\n")
                return p


# === –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è ===
if __name__ == "__main__":
    generator = PrimeGenerator()

    print("\n–ì–µ–Ω–µ—Ä–∞—Ü–∏—è 21-–±–∏—Ç–Ω–æ–≥–æ –ø—Ä–æ—Å—Ç–æ–≥–æ —á–∏—Å–ª–∞...")
    prime = generator.generate_prime(21)





import random
import math


def fast_pow_mod(a, exponent, n, operation_name=""):
    """–ë—ã—Å—Ç—Ä–æ–µ –≤–æ–∑–≤–µ–¥–µ–Ω–∏–µ –≤ —Å—Ç–µ–ø–µ–Ω—å –ø–æ –º–æ–¥—É–ª—é —Å –≤—ã–≤–æ–¥–æ–º —à–∞–≥–æ–≤"""
    i = exponent
    p = 1
    a_k = a % n
    step = 1

    print(f"\n{operation_name} —á–∏—Å–ª–∞ {a}:")
    print(f"{'k':>2} | {'a_k':>10} | {'i':>10} | {'s':>3} | {'p':>10}")
    print("-" * 45)

    while i > 0:
        s = i % 2
        if s == 1:
            p = (p * a_k) % n
        print(f"{step:>2} | {a_k:>10} | {i:>10} | {s:>3} | {p:>10}")
        a_k = (a_k * a_k) % n
        i = i // 2
        step += 1

    print(f"–ò—Ç–æ–≥–æ–≤—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç: {p} ({a}^{exponent} mod {n})\n")
    return p


class PrimeGenerator:
    def __init__(self):
        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –º–∞–ª—ã–µ –ø—Ä–æ—Å—Ç—ã–µ —á–∏—Å–ª–∞ –¥–æ 200 –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏
        self.small_primes = self._generate_small_primes(200)

    def _generate_small_primes(self, limit):
        """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Å–ø–∏—Å–æ–∫ –ø—Ä–æ—Å—Ç—ã—Ö —á–∏—Å–µ–ª –¥–æ –∑–∞–¥–∞–Ω–Ω–æ–≥–æ –ø—Ä–µ–¥–µ–ª–∞"""
        sieve = [True] * (limit + 1)
        sieve[0] = sieve[1] = False

        for i in range(2, int(math.sqrt(limit)) + 1):
            if sieve[i]:
                for j in range(i * i, limit + 1, i):
                    sieve[j] = False

        return [i for i, is_prime in enumerate(sieve) if is_prime]

    def rabin_miller_test(self, p, k=5, show_steps=False):
        """
        –¢–µ—Å—Ç –†–∞–±–∏–Ω–∞‚Äì–ú–∏–ª–ª–µ—Ä–∞ –Ω–∞ –ø—Ä–æ—Å—Ç–æ—Ç—É —Å —Ä–∞—Å—á–µ—Ç–æ–º –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏
        """
        if p == 2 or p == 3:
            return True
        if p <= 1 or p % 2 == 0:
            return False

        # –†–∞–∑–ª–æ–∂–µ–Ω–∏–µ p-1 = 2^b * m
        b = 0
        m = p - 1
        while m % 2 == 0:
            m //= 2
            b += 1

        print(f"\n--- –ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–∞ –†–∞–±–∏–Ω–∞‚Äì–ú–∏–ª–ª–µ—Ä–∞ –¥–ª—è —á–∏—Å–ª–∞ {p} ---")
        print(f"–†–∞–∑–ª–æ–∂–µ–Ω–∏–µ: {p-1} = 2^{b} * {m}")

        passed_tests = 0
        probability_history = []

        for test_num in range(1, k + 1):
            a = random.randint(2, p - 2)
            print(f"\n=== –¢–µ—Å—Ç #{test_num}: —Å–≤–∏–¥–µ—Ç–µ–ª—å a = {a} ===")

            if show_steps:
                z = fast_pow_mod(a, m, p, f"–í—ã—á–∏—Å–ª–µ–Ω–∏–µ a^m mod p")
            else:
                z = pow(a, m, p)
                print(f"–í—ã—á–∏—Å–ª–µ–Ω–∏–µ z = a^m mod p = {a}^{m} mod {p} = {z}")

            # –®–∞–≥ (3): –µ—Å–ª–∏ z = 1 –∏–ª–∏ z = p-1, —Ç–µ—Å—Ç –ø—Ä–æ–π–¥–µ–Ω
            if z == 1 or z == p - 1:
                passed_tests += 1
                error_prob = (1/4) ** passed_tests
                confidence = (1 - error_prob) * 100

                print(f"‚úì –¢–µ—Å—Ç #{test_num} –ø—Ä–æ–π–¥–µ–Ω (z = {z})")
                print(f"  –ü—Ä–æ–π–¥–µ–Ω–æ —Ç–µ—Å—Ç–æ–≤: {passed_tests}/{test_num}")
                print(f"  –¢–µ–∫—É—â–∞—è –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –ø—Ä–æ—Å—Ç–æ—Ç—ã: {confidence:.6f}%")
                continue

            j = 0
            test_passed = False

            print(f"–ù–∞—á–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ z = {z}")
            print(f"–¶–∏–∫–ª –ø–æ j –æ—Ç 0 –¥–æ {b-1}:")

            # –®–∞–≥ (5): –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ–µ –≤–æ–∑–≤–µ–¥–µ–Ω–∏–µ –≤ –∫–≤–∞–¥—Ä–∞—Ç
            while j < b - 1:
                j += 1

                print(f"  j = {j}:")
                
                if show_steps:
                    z_prev = z
                    z = fast_pow_mod(z, 2, p, f"–í–æ–∑–≤–µ–¥–µ–Ω–∏–µ –≤ –∫–≤–∞–¥—Ä–∞—Ç (—à–∞–≥ {j})")
                    print(f"    z = z_prev¬≤ mod p = {z_prev}¬≤ mod {p} = {z}")
                else:
                    z_prev = z
                    z = pow(z, 2, p)
                    print(f"    z = z_prev¬≤ mod p = {z_prev}¬≤ mod {p} = {z}")

                # –®–∞–≥ (4): –µ—Å–ª–∏ j > 0 –∏ z = 1 - —á–∏—Å–ª–æ —Å–æ—Å—Ç–∞–≤–Ω–æ–µ
                if j > 0 and z == 1:
                    print(f"‚úó –¢–µ—Å—Ç #{test_num} –ø—Ä–æ–≤–∞–ª–µ–Ω (j={j}, z=1)")
                    print(f"  –ü—Ä–æ–π–¥–µ–Ω–æ —Ç–µ—Å—Ç–æ–≤ –¥–æ –ø—Ä–æ–≤–∞–ª–∞: {passed_tests}/{test_num}")
                    if passed_tests > 0:
                        final_error_prob = (1/4) ** passed_tests
                        final_confidence = (1 - final_error_prob) * 100
                        print(f"  –ò—Ç–æ–≥–æ–≤–∞—è –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –ø—Ä–æ—Å—Ç–æ—Ç—ã: {final_confidence:.6f}%")
                    return False

                # –®–∞–≥ (5): –µ—Å–ª–∏ z = p-1 - —Ç–µ—Å—Ç –ø—Ä–æ–π–¥–µ–Ω
                if z == p - 1:
                    passed_tests += 1
                    error_prob = (1/4) ** passed_tests
                    confidence = (1 - error_prob) * 100

                    print(f"‚úì –¢–µ—Å—Ç #{test_num} –ø—Ä–æ–π–¥–µ–Ω (j={j}, z={p-1})")
                    print(f"  –ü—Ä–æ–π–¥–µ–Ω–æ —Ç–µ—Å—Ç–æ–≤: {passed_tests}/{test_num}")
                    print(f"  –¢–µ–∫—É—â–∞—è –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –ø—Ä–æ—Å—Ç–æ—Ç—ã: {confidence:.6f}%")
                    test_passed = True
                    break
                else:
                    print(f"    z = {z} ‚â† {p-1}, –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º...")

            # –®–∞–≥ (6): –µ—Å–ª–∏ j = b –∏ z ‚â† p-1 - —á–∏—Å–ª–æ —Å–æ—Å—Ç–∞–≤–Ω–æ–µ
            if not test_passed and z != p - 1:
                print(f"‚úó –¢–µ—Å—Ç #{test_num} –ø—Ä–æ–≤–∞–ª–µ–Ω (j –¥–æ—Å—Ç–∏–≥–ª–æ {b}, z={z} ‚â† {p-1})")
                print(f"  –ü—Ä–æ–π–¥–µ–Ω–æ —Ç–µ—Å—Ç–æ–≤ –¥–æ –ø—Ä–æ–≤–∞–ª–∞: {passed_tests}/{test_num}")
                if passed_tests > 0:
                    final_error_prob = (1/4) ** passed_tests
                    final_confidence = (1 - final_error_prob) * 100
                    print(f"  –ò—Ç–æ–≥–æ–≤–∞—è –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –ø—Ä–æ—Å—Ç–æ—Ç—ã: {final_confidence:.6f}%")
                return False

        # –í—Å–µ —Ç–µ—Å—Ç—ã –ø—Ä–æ–π–¥–µ–Ω—ã —É—Å–ø–µ—à–Ω–æ
        final_error_prob = (1/4) ** passed_tests
        final_confidence = (1 - final_error_prob) * 100

        print(f"\nüéâ –í–°–ï –¢–ï–°–¢–´ –ü–†–û–ô–î–ï–ù–´ –£–°–ü–ï–®–ù–û!")
        print(f"üìä –ò—Ç–æ–≥–æ–≤—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã:")
        print(f"   –ü—Ä–æ–π–¥–µ–Ω–æ —Ç–µ—Å—Ç–æ–≤: {passed_tests}/{k}")
        print(f"   –í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –ø—Ä–æ—Å—Ç–æ—Ç—ã: {final_confidence:.8f}%")

        return True

    def is_divisible_by_small_primes(self, n):
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –¥–µ–ª–∏–º–æ—Å—Ç—å –Ω–∞ –º–∞–ª—ã–µ –ø—Ä–æ—Å—Ç—ã–µ —á–∏—Å–ª–∞"""
        for prime in self.small_primes:
            if prime >= n:
                break
            if n % prime == 0:
                return True
        return False

    def generate_prime(self, bits):
        """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –ø—Ä–æ—Å—Ç–æ–µ —á–∏—Å–ª–æ –∑–∞–¥–∞–Ω–Ω–æ–π –±–∏—Ç–æ–≤–æ–π –¥–ª–∏–Ω—ã"""
        while True:
            # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ —á–∏—Å–ª–∞ –∑–∞–¥–∞–Ω–Ω–æ–π –¥–ª–∏–Ω—ã
            p = random.getrandbits(bits)

            # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—Ç–∞—Ä—à–∏–π –∏ –º–ª–∞–¥—à–∏–π –±–∏—Ç—ã
            p |= (1 << (bits - 1))  # —Å—Ç–∞—Ä—à–∏–π –±–∏—Ç = 1
            p |= 1  # –º–ª–∞–¥—à–∏–π –±–∏—Ç = 1 (–Ω–µ—á—ë—Ç–Ω–æ—Å—Ç—å)

            if p.bit_length() != bits:
                continue

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥–µ–ª–∏–º–æ—Å—Ç—å –º–∞–ª—ã–º–∏ –ø—Ä–æ—Å—Ç—ã–º–∏
            if self.is_divisible_by_small_primes(p):
                continue

            # –¢–µ—Å—Ç –†–∞–±–∏–Ω–∞‚Äì–ú–∏–ª–ª–µ—Ä–∞
            if self.rabin_miller_test(p, k=5):
                print(f"\n‚úÖ –ù–∞–π–¥–µ–Ω–æ –≤–µ—Ä–æ—è—Ç–Ω–æ –ø—Ä–æ—Å—Ç–æ–µ —á–∏—Å–ª–æ: {p}")
                print(f"üìè –ë–∏—Ç–æ–≤–∞—è –¥–ª–∏–Ω–∞: {p.bit_length()} –±–∏—Ç\n")
                return p


# === –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è ===
if __name__ == "__main__":
    generator = PrimeGenerator()

    print("\n–ì–µ–Ω–µ—Ä–∞—Ü–∏—è 21-–±–∏—Ç–Ω–æ–≥–æ –ø—Ä–æ—Å—Ç–æ–≥–æ —á–∏—Å–ª–∞...")
    prime = generator.generate_prime(21)



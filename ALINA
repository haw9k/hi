import math


def gcd(a, b):
    """Наибольший общий делитель"""
    while b != 0:
        a, b = b, a % b
    return a


def modinv(a, m):
    """Нахождение обратного элемента по модулю"""
    m0, x0, x1 = m, 0, 1
    while a > 1:
        q = a // m
        a, m = m, a % m
        x0, x1 = x1 - q * x0, x0
    if x1 < 0:
        x1 += m0
    return x1


def text_to_numbers(text, alphabet):
    """Преобразование текста в числа по позиции в алфавите"""
    numbers = []
    for char in text:
        if char in alphabet:
            numbers.append(alphabet.index(char) + 1)
        else:
            numbers.append(0)
    return numbers


def numbers_to_text(numbers, alphabet):
    """Преобразование чисел обратно в текст"""
    text = ""
    for num in numbers:
        if 1 <= num <= len(alphabet):
            text += alphabet[num - 1]
        else:
            text += "?"
    return text


def numbers_to_text_encrypted(numbers, alphabet):
    """Преобразование зашифрованных чисел в текст"""
    text = ""
    for num in numbers:
        encrypted_index = (num - 1) % len(alphabet) + 1
        if 1 <= encrypted_index <= len(alphabet):
            text += alphabet[encrypted_index - 1]
        else:
            text += "?"
    return text


def fast_pow_mod(a, exponent, n, operation_name):
    """Быстрое возведение в степень по модулю с выводом шагов"""
    i = exponent
    p = 1
    a_k = a % n
    step = 1

    print(f"{operation_name} числа {a}:")
    print(f"{'k':>2} | {'a_k':>5} | {'i':>5} | {'s':>3} | {'p':>5}")
    print("-" * 30)

    while i > 0:
        s = i % 2
        if s == 1:
            p = (p * a_k) % n
        print(f"{step:>2} | {a_k:>5} | {i:>5} | {s:>3} | {p:>5}")
        a_k = (a_k * a_k) % n
        i = i // 2
        step += 1

    print(f"Итоговый результат: {p} ({a}^{exponent} mod {n})\n")
    return p


def get_valid_d(phi):
    """Получение корректного значения d от пользователя с проверкой взаимной простоты"""
    while True:
        try:
            d = int(input(f"Введите значение d (1 < d < {phi}, взаимно простое с {phi}): "))

            if d <= 1 or d >= phi:
                print(f"Ошибка: d должно быть в диапазоне 1 < d < {phi}")
                continue

            if gcd(d, phi) != 1:
                print(f"Ошибка: d = {d} и φ(n) = {phi} не взаимно просты (НОД = {gcd(d, phi)})")
                print("Попробуйте другое значение.")
                continue

            return d

        except ValueError:
            print("Ошибка: введите целое число.")


def manual_rsa_encrypt_decrypt():
    """
    d — взаимно простое с φ(n)
    e — обратный элемент
    Открытый ключ (e, n), закрытый ключ (d, n)
    """

    alphabet = "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ"

    print("=" * 60)
    print("RSA ШИФРОВАНИЕ И РАСШИФРОВКА ")
    print("=" * 60)

    p = int(input("Введите первое простое число p: "))
    q = int(input("Введите второе простое число q: "))
    plaintext = input("Введите текст для шифрования (русские буквы): ").upper()

    n = p * q
    phi = (p - 1) * (q - 1)

    print(f"\n--- ВЫЧИСЛЕННЫЕ ПАРАМЕТРЫ ---")
    print(f"n = p * q = {p} * {q} = {n}")
    print(f"φ(n) = (p-1) * (q-1) = {p - 1} * {q - 1} = {phi}")

    # Получаем d от пользователя с проверкой
    d = get_valid_d(phi)

    # e — обратный элемент к d по модулю φ(n)
    e = modinv(d, phi)

    print(f"\n--- ПАРАМЕТРЫ RSA ---")
    print(f"p = {p}, q = {q}")
    print(f"n = {n}, φ(n) = {phi}")
    print(f"Выбранное d = {d} (взаимно простое с {phi} ✓)")
    print(f"Вычисленное e = {e} (обратный элемент к d по модулю φ(n))")
    print(f"Открытый ключ (e, n) = ({e}, {n})")
    print(f"Закрытый ключ (d, n) = ({d}, {n})")
    print(f"Алфавит ({len(alphabet)} букв): {alphabet}")

    plain_numbers = text_to_numbers(plaintext, alphabet)
    print(f"\n--- ПРЕОБРАЗОВАНИЕ ТЕКСТА ---")
    print(f"Оригинальный текст: '{plaintext}'")
    print(f"Числовое представление: {plain_numbers}")

    # --- ШИФРОВАНИЕ ---
    print("\n" + "=" * 50)
    print(f"RSA ШИФРОВАНИЕ (используем e = {e})")
    print("=" * 50)

    encrypted_message = []
    for idx, m in enumerate(plain_numbers):
        print(f"Шифрование символа {idx + 1} ('{plaintext[idx]}' = {m}):")
        c = fast_pow_mod(m, e, n, "Шифрование")
        encrypted_message.append(c)

    encrypted_text = numbers_to_text_encrypted(encrypted_message, alphabet)
    print(f"Зашифрованное сообщение в числах: {encrypted_message}")
    print(f"Зашифрованное сообщение в тексте: '{encrypted_text}'")

    # --- РАСШИФРОВКА ---
    print("\n" + "=" * 50)
    print(f"RSA РАСШИФРОВКА (используем d = {d})")
    print("=" * 50)

    decrypted_message = []
    for idx, c in enumerate(encrypted_message):
        print(f"Расшифровка символа {idx + 1} (число {c}):")
        m = fast_pow_mod(c, d, n, "Расшифровка")
        decrypted_message.append(m)

    decrypted_text = numbers_to_text(decrypted_message, alphabet)

    print("\n" + "=" * 60)
    print("ИТОГОВЫЕ РЕЗУЛЬТАТЫ")
    print("=" * 60)
    print(f"Оригинальный текст: '{plaintext}'")
    print(f"Зашифрованный текст: '{encrypted_text}'")
    print(f"Расшифрованный текст: '{decrypted_text}'")


if __name__ == "__main__":
    manual_rsa_encrypt_decrypt()

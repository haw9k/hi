#rabin_miller

import random
import math


def fast_pow_mod(a, exponent, n, operation_name=""):
    """Быстрое возведение в степень по модулю с выводом шагов"""
    i = exponent
    p = 1
    a_k = a % n
    step = 1

    print(f"\n{operation_name} числа {a}:")
    print(f"{'k':>2} | {'a_k':>10} | {'i':>10} | {'s':>3} | {'p':>10}")
    print("-" * 45)

    while i > 0:
        s = i % 2
        if s == 1:
            p = (p * a_k) % n
        print(f"{step:>2} | {a_k:>10} | {i:>10} | {s:>3} | {p:>10}")
        a_k = (a_k * a_k) % n
        i = i // 2
        step += 1

    print(f"Итоговый результат: {p} ({a}^{exponent} mod {n})\n")
    return p


class PrimeGenerator:
    def __init__(self):
        # Генерируем малые простые числа до 200 для фильтрации
        self.small_primes = self._generate_small_primes(200)

    def _generate_small_primes(self, limit):
        """Генерирует список простых чисел до заданного предела"""
        sieve = [True] * (limit + 1)
        sieve[0] = sieve[1] = False

        for i in range(2, int(math.sqrt(limit)) + 1):
            if sieve[i]:
                for j in range(i * i, limit + 1, i):
                    sieve[j] = False

        return [i for i, is_prime in enumerate(sieve) if is_prime]

    def rabin_miller_test(self, p, k=5, show_steps=False):
        """
        Тест Рабина–Миллера на простоту с расчетом вероятности
        """
        if p == 2 or p == 3:
            return True
        if p <= 1 or p % 2 == 0:
            return False

        # Разложение p-1 = 2^b * m
        b = 0
        m = p - 1
        while m % 2 == 0:
            m //= 2
            b += 1

        print(f"\n--- Запуск теста Рабина–Миллера для числа {p} ---")
        print(f"Разложение: {p-1} = 2^{b} * {m}")

        passed_tests = 0
        probability_history = []

        for test_num in range(1, k + 1):
            a = random.randint(2, p - 2)
            print(f"\n=== Тест #{test_num}: свидетель a = {a} ===")

            if show_steps:
                z = fast_pow_mod(a, m, p, f"Вычисление a^m mod p")
            else:
                z = pow(a, m, p)
                print(f"Вычисление z = a^m mod p = {a}^{m} mod {p} = {z}")

            # Шаг (3): если z = 1 или z = p-1, тест пройден
            if z == 1 or z == p - 1:
                passed_tests += 1
                error_prob = (1/4) ** passed_tests
                confidence = (1 - error_prob) * 100

                print(f"✓ Тест #{test_num} пройден (z = {z})")
                print(f"  Пройдено тестов: {passed_tests}/{test_num}")
                print(f"  Текущая вероятность простоты: {confidence:.6f}%")
                continue

            j = 0
            test_passed = False

            print(f"Начальное значение z = {z}")
            print(f"Цикл по j от 0 до {b-1}:")

            # Шаг (5): последовательное возведение в квадрат
            while j < b - 1:
                j += 1

                print(f"  j = {j}:")
                
                if show_steps:
                    z_prev = z
                    z = fast_pow_mod(z, 2, p, f"Возведение в квадрат (шаг {j})")
                    print(f"    z = z_prev² mod p = {z_prev}² mod {p} = {z}")
                else:
                    z_prev = z
                    z = pow(z, 2, p)
                    print(f"    z = z_prev² mod p = {z_prev}² mod {p} = {z}")

                # Шаг (4): если j > 0 и z = 1 - число составное
                if j > 0 and z == 1:
                    print(f"✗ Тест #{test_num} провален (j={j}, z=1)")
                    print(f"  Пройдено тестов до провала: {passed_tests}/{test_num}")
                    if passed_tests > 0:
                        final_error_prob = (1/4) ** passed_tests
                        final_confidence = (1 - final_error_prob) * 100
                        print(f"  Итоговая вероятность простоты: {final_confidence:.6f}%")
                    return False

                # Шаг (5): если z = p-1 - тест пройден
                if z == p - 1:
                    passed_tests += 1
                    error_prob = (1/4) ** passed_tests
                    confidence = (1 - error_prob) * 100

                    print(f"✓ Тест #{test_num} пройден (j={j}, z={p-1})")
                    print(f"  Пройдено тестов: {passed_tests}/{test_num}")
                    print(f"  Текущая вероятность простоты: {confidence:.6f}%")
                    test_passed = True
                    break
                else:
                    print(f"    z = {z} ≠ {p-1}, продолжаем...")

            # Шаг (6): если j = b и z ≠ p-1 - число составное
            if not test_passed and z != p - 1:
                print(f"✗ Тест #{test_num} провален (j достигло {b}, z={z} ≠ {p-1})")
                print(f"  Пройдено тестов до провала: {passed_tests}/{test_num}")
                if passed_tests > 0:
                    final_error_prob = (1/4) ** passed_tests
                    final_confidence = (1 - final_error_prob) * 100
                    print(f"  Итоговая вероятность простоты: {final_confidence:.6f}%")
                return False

        # Все тесты пройдены успешно
        final_error_prob = (1/4) ** passed_tests
        final_confidence = (1 - final_error_prob) * 100

        print(f"\n ВСЕ ТЕСТЫ ПРОЙДЕНЫ УСПЕШНО!")
        print(f" Итоговые результаты:")
        print(f"   Пройдено тестов: {passed_tests}/{k}")
        print(f"   Вероятность простоты: {final_confidence:.8f}%")

        return True

    def is_divisible_by_small_primes(self, n):
        """Проверяет делимость на малые простые числа"""
        for prime in self.small_primes:
            if prime >= n:
                break
            if n % prime == 0:
                return True
        return False

    def generate_prime(self, bits):
        """Генерирует простое число заданной битовой длины"""
        while True:
            # Генерация случайного числа заданной длины
            p = random.getrandbits(bits)

            # Устанавливаем старший и младший биты
            p |= (1 << (bits - 1))  # старший бит = 1
            p |= 1  # младший бит = 1 (нечётность)

            if p.bit_length() != bits:
                continue

            # Проверка на делимость малыми простыми
            if self.is_divisible_by_small_primes(p):
                continue

            # Тест Рабина–Миллера
            if self.rabin_miller_test(p, k=5):
                print(f"\n Найдено вероятно простое число: {p}")
                print(f" Битовая длина: {p.bit_length()} бит\n")
                return p


# === Пример использования ===
if __name__ == "__main__":
    generator = PrimeGenerator()

    print("\nГенерация 21-битного простого числа...")
    prime = generator.generate_prime(21)



#Difi_Helman
import random
import math


def CustomMod(number, step, mod):
    p = 1
    while step > 0:
        s = step % 2
        if s == 1:
            p = (p * number) % mod
        number = (number * number) % mod
        step = (step - s) // 2
    return p



class MilerRabin:
    def Randomer(self, min_val):
        num = int(random.random() * min_val)
        binary = list(bin(num)[2:])
        binary[0] = "1"
        binary[-1] = "1"
        num = int("".join(binary), 2)
        return num

    def searchB(self, num):
        acc = num - 1
        b = 0
        while acc % 2 == 0:
            b += 1
            acc //= 2
        return b

    def searchM(self, num, b):
        return (num - 1) // pow(2, b)

    def startExamination(self, num, b, m):
        for i in range(2, 256):
            if num % i == 0:
                return False
        a = random.randint(0, num)
        j = 0
        z = CustomMod(a, m, num)
        if z == 1 or z == num - 1:
            return True
        else:
            while j != b:
                j += 1
                z = CustomMod(a, m * pow(2, j), num)
                if z == num - 1:
                    return True
        return False

    def createSimple(self):
        min_val = int('1' + '0' * 21, 2)
        num = self.Randomer(min_val)
        b = self.searchB(num)
        m = self.searchM(num, b)

        iter_ = 0
        count = 0

        while iter_ != 5:
            iter_ += 1
            count += 1
            result = self.startExamination(num, b, m)
            if result != True:
                if count >= 30:
                    break
                iter_ = 0
                num += 2
                b = self.searchB(num)
                m = self.searchM(num, b)
        return num



def findPrimitiveElement(simple):
    simpleList = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,
                  59,61,67,71,73,79,83,89,97]
    currentSimpleList = []

    for s in simpleList:
        if (simple - 1) % s == 0:
            currentSimpleList.append(s)

    primitive = 0
    for i in range(simple // 2, 2, -1):
        if primitive == 0:
            primitive = i
            for s in currentSimpleList:
                if CustomMod(i, s, simple) == 1:
                    primitive = 0
                    break
        else:
            break
    return primitive



class Encryption:
    letters = "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдеёжзийклмнопрстуфхцчшщъыьэюя "

    def encript(self, worldNums, keys):
        encodeText = ''
        encodeNumber = []

        for code in worldNums:
            p = 1
            a = code
            I = keys['d']

            while I > 0:
                s = I % 2
                if s == 1:
                    p = (p * a) % keys['n']
                a = (a * a) % keys['n']
                I = (I - s) // 2

            normal_p = p
            if normal_p > len(self.letters):
                normal_p = p - ((p // (len(self.letters) - 1)) * (len(self.letters) - 1))

            encodeNumber.append(p)
            encodeText += self.letters[normal_p - 1]

        return {'text': encodeText, 'worldNums': encodeNumber}



def createOpenKeys(p, g):
    X = random.randint(0, p - 1)
    Y = CustomMod(g, X, p)
    return {"X": X, "Y": Y}

def createCloseKey(Y, X, p):
    return CustomMod(Y, X, p)

def main():
    simpleGenerater = MilerRabin()

    p = simpleGenerater.createSimple()  # или p = 41
    g = findPrimitiveElement(p)

    print(f"Параметры системы:")
    print(f"  p = {p}")
    print(f"  g = {g}")
    print("-" * 45)

    AliceKeys = createOpenKeys(p, g)
    BobKeys = createOpenKeys(p, g)

    print(f"Алиса:")
    print(f"  Приватный ключ Xa = {AliceKeys['X']}")
    print(f"  Публичный ключ Ya = {AliceKeys['Y']}")
    print()
    print(f"Боб:")
    print(f"  Приватный ключ Xb = {BobKeys['X']}")
    print(f"  Публичный ключ Yb = {BobKeys['Y']}")
    print("-" * 45)

    alice_secret = createCloseKey(BobKeys['Y'], AliceKeys['X'], p)
    bob_secret   = createCloseKey(AliceKeys['Y'], BobKeys['X'], p)
    correct_key  = createCloseKey(g, AliceKeys['X'] * BobKeys['X'], p)

    print(f"Обмен ключами:")
    print(f"  Общий секрет (Алиса): {alice_secret}")
    print(f"  Общий секрет (Боб):   {bob_secret}")
    print()
    print(f"Проверка:")
    print(f"  Контрольное вычисление (g^(Xa*Xb) mod p): {correct_key}")
    print(f"\nРезультат: {' Совпадают, обмен успешен!' if alice_secret == bob_secret == correct_key else '❌ Ошибка! Ключи не совпадают.'}")



if __name__ == "__main__":
    main()
